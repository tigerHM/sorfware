1.主从复制,读写分离
文章参考:
https://zhuanlan.zhihu.com/p/199217698
主从复制、读写分离就是为了数据库能支持更大的并发。

主从复制的原理
①当Master节点进行insert、update、delete操作时，会按顺序写入到binlog中。
②salve从库连接master主库，Master有多少个slave就会创建多少个binlog dump线程。
③当Master节点的binlog发生变化时，binlog dump 线程会通知所有的salve节点，并将相应的binlog内容推送给slave节点。
④I/O线程接收到 binlog 内容后，将内容写入到本地的 relay-log。
⑤SQL线程读取I/O线程写入的relay-log，并且根据 relay-log 的内容对从数据库做对应的操作。



查看数据库各表记录数：
use information_schema;
select table_name,table_rows from tables  where TABLE_SCHEMA = '数据库名字'  order by table_rows desc;

查看数据库表表所占的容量（表的数据和索引）：
select sum(DATA_LENGTH)+sum(INDEX_LENGTH) from information_schema.tables where table_schema='testdb';
得到的是字节为单位。



MVCC(Multi Version Concurrency Control的简称)，代表多版本并发控制。
参考文章：https://www.jianshu.com/p/f692d4f8a53e



在8.0后的mysql版本中，函数支持窗口函数：rank(),LEAD(),ROW_NUMBER()等.
官网通过比对版本的文档可以看到：
https://dev.mysql.com/doc/refman/5.7/en/

其它方式实现类似rank()功能的方法：
参考：https://www.jianshu.com/p/bb1b72a1623e

mysql实现排序：（使用的版本：5.7.31）
场景1.全局按某个字段排序,输出排名情况
SELECT emp_no, salary, from_date, @curRank := @curRank + 1 AS rank FROM salaries, (SELECT @curRank := 0) q ORDER BY salary;
得到如下：
+--------+--------+------------+------+
| emp_no | salary | from_date  | rank |
+--------+--------+------------+------+
|  10003 |  43311 | 2001-12-01 |    1 |
|  10002 |  72527 | 2001-08-02 |    2 |
|  10004 |  72527 | 2001-12-01 |    3 |
|  10001 |  88958 | 2002-06-22 |    4 |

场景2.按某个字段实现分组排序,输出排名情况


